import{r as o,j as h,t as x}from"./app-BibepUcb.js";import{u as E}from"./createLucideIcon-C1hfjJhF.js";function U(e,n){const t=o.createContext(n),r=s=>{const{children:u,...c}=s,a=o.useMemo(()=>c,Object.values(c));return h.jsx(t.Provider,{value:a,children:u})};r.displayName=e+"Provider";function i(s){const u=o.useContext(t);if(u)return u;if(n!==void 0)return n;throw new Error(`\`${s}\` must be used within \`${e}\``)}return[r,i]}function _(e,n=[]){let t=[];function r(s,u){const c=o.createContext(u),a=t.length;t=[...t,u];const l=f=>{const{scope:p,children:m,...v}=f,g=p?.[e]?.[a]||c,C=o.useMemo(()=>v,Object.values(v));return h.jsx(g.Provider,{value:C,children:m})};l.displayName=s+"Provider";function d(f,p){const m=p?.[e]?.[a]||c,v=o.useContext(m);if(v)return v;if(u!==void 0)return u;throw new Error(`\`${f}\` must be used within \`${s}\``)}return[l,d]}const i=()=>{const s=t.map(u=>o.createContext(u));return function(c){const a=c?.[e]||s;return o.useMemo(()=>({[`__scope${e}`]:{...c,[e]:a}}),[c,a])}};return i.scopeName=e,[r,M(i,...n)]}function M(...e){const n=e[0];if(e.length===1)return n;const t=()=>{const r=e.map(i=>({useScope:i(),scopeName:i.scopeName}));return function(s){const u=r.reduce((c,{useScope:a,scopeName:l})=>{const f=a(s)[`__scope${l}`];return{...c,...f}},{});return o.useMemo(()=>({[`__scope${n.scopeName}`]:u}),[u])}};return t.scopeName=n.scopeName,t}var S=globalThis?.document?o.useLayoutEffect:()=>{},P=x[" useInsertionEffect ".trim().toString()]||S;function $({prop:e,defaultProp:n,onChange:t=()=>{},caller:r}){const[i,s,u]=A({defaultProp:n,onChange:t}),c=e!==void 0,a=c?e:i;{const d=o.useRef(e!==void 0);o.useEffect(()=>{const f=d.current;f!==c&&console.warn(`${r} is changing from ${f?"controlled":"uncontrolled"} to ${c?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),d.current=c},[c,r])}const l=o.useCallback(d=>{if(c){const f=w(d)?d(e):d;f!==e&&u.current?.(f)}else s(d)},[c,e,s,u]);return[a,l]}function A({defaultProp:e,onChange:n}){const[t,r]=o.useState(e),i=o.useRef(t),s=o.useRef(n);return P(()=>{s.current=n},[n]),o.useEffect(()=>{i.current!==t&&(s.current?.(t),i.current=t)},[t,i]),[t,r,s]}function w(e){return typeof e=="function"}function R(e,n){return o.useReducer((t,r)=>n[t][r]??t,e)}var y=e=>{const{present:n,children:t}=e,r=O(n),i=typeof t=="function"?t({present:r.isPresent}):o.Children.only(t),s=E(r.ref,T(i));return typeof t=="function"||r.isPresent?o.cloneElement(i,{ref:s}):null};y.displayName="Presence";function O(e){const[n,t]=o.useState(),r=o.useRef(null),i=o.useRef(e),s=o.useRef("none"),u=e?"mounted":"unmounted",[c,a]=R(u,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}});return o.useEffect(()=>{const l=N(r.current);s.current=c==="mounted"?l:"none"},[c]),S(()=>{const l=r.current,d=i.current;if(d!==e){const p=s.current,m=N(l);e?a("MOUNT"):m==="none"||l?.display==="none"?a("UNMOUNT"):a(d&&p!==m?"ANIMATION_OUT":"UNMOUNT"),i.current=e}},[e,a]),S(()=>{if(n){let l;const d=n.ownerDocument.defaultView??window,f=m=>{const g=N(r.current).includes(CSS.escape(m.animationName));if(m.target===n&&g&&(a("ANIMATION_END"),!i.current)){const C=n.style.animationFillMode;n.style.animationFillMode="forwards",l=d.setTimeout(()=>{n.style.animationFillMode==="forwards"&&(n.style.animationFillMode=C)})}},p=m=>{m.target===n&&(s.current=N(r.current))};return n.addEventListener("animationstart",p),n.addEventListener("animationcancel",f),n.addEventListener("animationend",f),()=>{d.clearTimeout(l),n.removeEventListener("animationstart",p),n.removeEventListener("animationcancel",f),n.removeEventListener("animationend",f)}}else a("ANIMATION_END")},[n,a]),{isPresent:["mounted","unmountSuspended"].includes(c),ref:o.useCallback(l=>{r.current=l?getComputedStyle(l):null,t(l)},[])}}function N(e){return e?.animationName||"none"}function T(e){let n=Object.getOwnPropertyDescriptor(e.props,"ref")?.get,t=n&&"isReactWarning"in n&&n.isReactWarning;return t?e.ref:(n=Object.getOwnPropertyDescriptor(e,"ref")?.get,t=n&&"isReactWarning"in n&&n.isReactWarning,t?e.props.ref:e.props.ref||e.ref)}export{y as P,S as a,U as b,_ as c,$ as u};
